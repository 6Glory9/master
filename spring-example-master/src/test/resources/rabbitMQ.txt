RabbitMQ
是一个消息代理。它的核心原理非常简单：接收和发送消息。你可以把它想像成一个邮局：你把信件放入邮箱，
邮递员就会把信件投递到你的收件人处。在这个比喻中，RabbitMQ就扮演着邮箱、邮局以及邮递员的角色

RabbitMQ使用的是AMQP协议。要使用她你就必须需要一个使用同样协议的库。几乎所有的编程语言都有可选择的库。python也是一样，可以从以下几个库中选择：
	py-amqplib
	txAMQP
	pika


生成者

队列

消费者

交换机（exchange）
消息是不能直接发送到队列，它需要发送到交换机（exchange）中。
用默认的交换机（exchange），它使用一个空字符串来标识。交换机允许我们指定某条消息需要投递到哪个队列，routing_key参数必须指定为队列的名称

1.工作队列
一个生成者，多个消费者。为了防止消费者漏单，提供消息响应机制。

消息响应（acknowledgments），消费者会通过一个ack（响应），告诉RabbitMQ已经收到并处理了某条消息，然后RabbitMQ就会释放并删除这条消息。
PS:消息是没有超时这个概念的；当工作者与它断开连的时候，RabbitMQ会重新发送消息，消费者一直挂不是悲剧了。

忘记确认
消费者出现问题，没有及时消息响应。队列一直积累，这样最终导致内在溢出。

消息持久化
在最终悲剧之前，会把队列和消息持久化(durable=true)


2.发布／订阅

生成者，通过扇型交换机发送到一个空的队列中。消费者通过临时队列绑定到扇型交换机上。如果扇型交换机没有监听者，消息会被忽略。

发布者（producer）只需要把消息发送给一个交换机（exchange）。交换机非常简单，它一边从发布者方接收消息，一边把消息推送到队列。交换机必须知道如何处理它接收到的消息，是应该推送到指定的队列还是是多个队列，或者是直接忽略消息。这些规则是通过交换机类型（exchange type）来定义的
exchange type 直连交换机（direct）, 主题交换机（topic）, （头交换机）headers和 扇型交换机（fanout），匿名的交换器

扇型交换机（fanout），它把消息发送给它所知道的所有队列。

临时队列
1.随机队列名 2.临时队列与消费者（consumer）断开连接的时候，这个队列应当被立即删除。(exclusive=true)

3.路由
4.主题路由
5.RPC

回调队列
一般来说通过RabbitMQ来实现RPC是很容易的。一个客户端发送请求信息，服务器端将其应用到一个回复信息中。为了接收到回复信息，客户端需要在发送请求的时候同时发送一个回调队列（callback queue）的地址